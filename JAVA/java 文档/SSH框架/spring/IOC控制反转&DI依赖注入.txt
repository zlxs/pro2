控制反转和依赖注入描述的是一个思想

IOC(控制反转):
bean的生成不用自己去new，统一由Spring来实例化(获得依赖对象的方式被反转了，由
自己new变成Spring来帮我们实例化)

DI(依赖注入):
bean之间的依赖关系交给Spring管理，不用自己去调用set方法来处理

如：原来类A的对象中有B类对象的引用需要这么来写
A a=new A();
B b=new B();
a.setB(b);

现在可以在Spring的配置文件中通过bean标签描述它门的关系，而由Spring来
帮我们实例化A和B类的对象，并让Spring帮我们调用set方法，使A初始化时
维护了B类对象的引用


---------------------------------------------------------------------------------------
关于Spring是如何完成这些操作的：
 Spring有个类ClassPathXmlApplicationContext，用来读取classpath下的Spring的xml配置文件，通过dom4j方式解析出
每个节点，再读取bean节点上的属性，实例化class，并以id的值为关键字存放在map中，Spring同时会解析
到bean中配置的属性和值，通过反射类的对应属性的set方法来自动为实例化的对象赋值，
当解析到一个bean的属性是另一个bean的引用时，会通过ref的值为key从map中取出对应的对象，
赋值到该bean的对应属性上去
注意：bean不是配置了就会实例化，而是用到时才去实例化，类似hibernate的延迟检索，为了节省资源
但是ApplicationContext会预先实例化单例bean
只有单例bean才会以id为关键字存放在map中，原型bean每次用到都new新的，不需要存放在map中
---------------------------------------------------------------------------------------

