
inverse属性：

"true"表示将关系维护的权力交给对方，"false"表示不交出维护权力（默认值）。

Inverse是hibernate双向关系中的基本概念。inverse的真正作用就是指定由哪一方来维护之间的关联关系。
当一方中指定了“inverse=false”（默认），那么那一方就有责任负责之间的关联关系。
一般在一对多双向关联关系中，将一方的inverse属性设置为true，即将主外键的关系交由多方来维护。
只有无外键方才能放弃关系维护

------------------------------------
维护关系是通过set方法，如1方：setOrders(Set)和多方：setCustomer(Customer) 方法来维护关系的
------------------------------------

inverse决定是否把对对象中集合的改动反映到数据中，所以inverse只对集合起作用
也就是只对one-to-many或many-to-many有效

一般只由多的一端来维护关系，这样效率高些，由一的一方维护时，会多执行update语句
  所以建议inverse="true"    这时改变集合不会改变数据库表的记录，即setOrders()不会修改数据库

一般通过多方：setCustomer()来维护，而不是由一方setOrders()来维护

-------------------------------------------------------------------------------------

cascade属性：级联操作，指定操作一方时，是否同时把与它关联的一方的改动反映到数据库中


save-update:保存或更新1的一端的数据时，同时把关联的多的一端的数据也保存或更新
all : 所有情况下均进行关联操作。 
none：所有情况下均不进行关联操作 
save-update:在执行save/update/saveOrUpdate时进行关联操作。 

delete：
     设置在1的一方时，在删除1的一端时，会先把关联的多的一方外键设置为null,再把多的一方全部删除
        所以要求外键不能设置为非空


     设置在多的一方时:删除多的一方，会试图删除1的一方，而删除1的一方时，
          由于该1的一方有其他多的一方的外键关联，会去把其它多的一方的外键设置为null，
   如果映射时配置外键不能为null(not-null="true") 则会抛异常。
  过程：删除多的一方，再删除1的一方，再把其他与1的一方关联的多的一方的外键设置为null,其他多的一方并不会删除


一般在多的一端设置为save-update

注解中：---------------
CascadeType.REFRESH：级联刷新，当多个用户同时作操作一个实体，
为了用户取到的数据是实时的，在用实体中的数据之前就可以调用一下refresh()方法！

CascadeType.REMOVE：级联删除

CascadeType.MERGE：级联更新，当调用了Merge()方法，
如果Order中的数据改变了会相应的更新OrderItem中的数据，

CascadeType.PERSIST：级联保存

CascadeType.ALL：包含以上所有级联属性。

csascade不能控制读取数据，默认读取1的一方时，不会把多的一方也读取出来
用fetch来控制读取


注意，做级联保存时，如果是双向关联，需要把两个关系通过set方法维护好，再保存，否则
只级联保存数据，但不保存数据之间的关系，1对多外键字段为null,多对多中间表也不会插入数据

多对多在保存中间表数据时，需要把两方的集合取出来，把值分别添加到两个集合中去，在把新的集合set到两个对象中
再进行保存，否则中间表会丢失原先的数据
-------------------------------------------------------------------------------------

Fetch属性： 抓取策略
  fetch"连接允许仅仅使用一个选择语句就将相关联的对象或一组值的集合随着他们的父对象的初始化而被初始化，
这种方法在使用到集合的情况下尤其有用，对于关联和集合来说，它有效的代替了映射文件中的外联接 与延迟声明

fetch="select",另外发送一条select语句抓取当前对象关联实体或集合
除非你显示的指定lazy="false"禁止延迟抓取，否则只有当你正真访问关联对象时，才会执行第二条select语句


fetch="join",hibernate会通过select语句使用外连接outer join来同时加载其关联实体或集合
此时lazy会失效,是立即加载

fetch="subselect",另外发送一条select语句抓取在前面查询到的所有实体对象的关联集合
除非你显示的指定lazy="false"禁止延迟抓取，否则只有当你正真访问关联对象时，才会执行第二条select语句  


注解中配置立即加载和延迟加载：

fetch=FetchType.LAZY：延迟加载  用到时才执行sql语句
fetch=FetchType.EAGER：及时加载  立即执行sql语句
-------------------------------------------------------------------------------------

lazy属性：    get不支持延迟加载，load支持
在映射文件中的 class节点中 添加 lazy="false"  load方法就会立即加载


set/list默认下是lazy=true ,支持懒加载，但当使用size()的时候依然要去
  查询整个set集合的内容。

lazy=extra比较智能，支持懒加载，当使用size()时，不会查询整个集合，
仅仅查询集合中元素的个数。当需要使用集合元素的内容时，再去查询集合内容。


注解中配置立即加载和延迟加载：

fetch=FetchType.LAZY：延迟加载  用到时才执行sql语句
fetch=FetchType.EAGER：及时加载  立即执行sql语句
