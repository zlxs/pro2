Oracle中采用"锁"来做并发处理的

排他锁：
   当数据对象被加上排他锁时，其他事物不能对它读取和修改

共享锁：
   加了共享锁的数据对象可以被其他事物读取，但不能修改


1.表级排它锁(X) exclusive mode

2.表级共享锁(S) share mode

3.表中行级排它锁(RSX) share row exclusive

语法:
  lock table table_name in mode;

例如:

--以共享锁锁表
lock table tbl_name in share mode;

--以排它锁锁表
lock table tbl_name in exclusive mode;

4.行级共享锁(RS) row share

5.行级排它锁(RX) row exclusive

注意:这两种锁是不需要通过专门的命令来进行加锁的!
     记住:所有的DML操作自动会去申请RX锁
	 所有的DQL语句默认会去申请RS锁!

	 但是在实际的开发中,有的时候,我们也是希望DQL去申请RX锁!

	 DQL如何去申请RX锁呢?

         A事物:select * from 表名 for update; //事物A 在查询时申请锁，在事物结束时才释放锁,A事物执行过程中，其他事物无法查询

	 B事物:select * from 表名 for update wait 5;//事物B在查询时，如果A事物没有结束，则最多等待5秒，
                5秒之后,资源还是没有获取的话,就离开!（A事物没有在5秒内释放锁，则停止等待，结束查询操作）

	 C事物:select * from 表名 for update nowait;//A不释放锁，C没有获取到资源，不等待,直接离开



悲观锁：
  悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，
所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。


如果要使用悲观锁，肯定在加载数据时就要锁住，通常采用for update语句
在sql语句最后加for update
如：select * from user where id=3 for update;


乐观锁：
  乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，
所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，
在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，
将此版本号一同读出，之后更新时，对此版本号加一。
此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，
如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

乐观锁适用于多读的应用类型，这样可以提高吞吐量，
像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。
