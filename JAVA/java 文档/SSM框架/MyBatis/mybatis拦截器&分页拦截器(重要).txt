mybatis拦截器拦截的不是mapper接口中的具体方法
而是针对以下的操作进行拦截
   1.拦截执行器的方法
   2.拦截参数的处理
   3.拦截结果集的处理
   4.拦截Sql语法构建的处理
所以拦截的对象是Executor、StatementHandler、ParameterHandler和ResultSetHandler这4个，拦截的方法是这4个对象的方法


@Intercepts用于表明当前的对象是一个Interceptor

@Signature则表明要拦截的接口、方法以及对应的参数类型
   method：要拦截的方法名
   args：方法上的参数
   type: 要拦截的接口的class
      4种：Executor、StatementHandler、ParameterHandler和ResultSetHandler
           这是在Mybatis的Configuration中写死了的，如果要支持拦截其他接口就需要我们重写Mybatis的Configuration。
           Mybatis可以对这四个接口中所有的方法进行拦截。
如： 
   Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
   ParameterHandler (getParameterObject, setParameters)
   ResultSetHandler (handleResultSets, handleOutputParameters)
   StatementHandler (prepare, parameterize, batch, update, query)


自定义拦截器案例及分析：

@Intercepts( {   //@Intercepts用于表明当前的对象是一个Interceptor
                 //@Signature则表明要拦截的接口、方法以及对应的参数类型
       @Signature(method = "query", type = Executor.class, args = {
              MappedStatement.class, Object.class, RowBounds.class,
              ResultHandler.class }),
       @Signature(method = "prepare", type = StatementHandler.class, args = { Connection.class }) })
public class MyInterceptor implements Interceptor {   //实现mybatis的Interceptor接口
 
    //target为被拦截的目标对象，即@Signature中type属性指定的接口的实现类
    //plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理
    public Object plugin(Object target) {
       //Plugin的wrap方法，它根据当前的Interceptor上面的注解定义哪些接口需要拦截，然后判断当前目标对象是否有实现对应需要拦截的接口，
       //如果没有则返回目标对象本身，如果有则返回一个代理对象。而这个代理对象的InvocationHandler正是一个Plugin。
       return Plugin.wrap(target, this);//this为拦截器本身
    }
 
    //经过plugin方法后，如果返回的是代理对象，才会经过interceptor方法，不是代理对象则不会调用这个方法
    public Object intercept(Invocation invocation) throws Throwable {
       //拦下来执行一些操作  
       //通过invocation参数可以获取目标对象、要执行的方法以及方法参数等
       // invocation.getTarget();获取拦截器拦截的接口实现类对象
       //...
       Object result = invocation.proceed();//执行目标对象的方法
       return result;
    }
   
    //setProperties方法是用于在Mybatis配置文件中指定一些属性的
    public void setProperties(Properties properties) {
       String prop1 = properties.getProperty("prop1");
       String prop2 = properties.getProperty("prop2");
       System.out.println(prop1 + "------" + prop2);
    }
 
}

注册拦截器：在mybatis的xml主配置文件中配置：
<plugins>
    <plugin interceptor="com.xxx.interceptor.MyInterceptor"></plugin>
</plugins>


拦截器的执行流程：

Plugin的wrap方法，它根据当前的Interceptor上面的注解定义哪些接口需要拦截，然后判断当前目标对象是否有实现对应需要拦截的接口，
如果没有则返回目标对象本身，如果有则返回一个代理对象。而这个代理对象的InvocationHandler正是一个Plugin。

当目标对象在执行接口方法时，如果是通过代理对象执行的，则会调用对应InvocationHandler的invoke方法，也就是Plugin的invoke方法。

invoke方法的逻辑是：如果当前执行的方法是定义好的需要拦截的方法，则把目标对象、要执行的方法以及方法参数封装成一个Invocation对象，
再把封装好的Invocation作为参数传递给当前拦截器的intercept方法。如果不需要拦截，则直接调用当前的方法。

Invocation中定义了定义了一个proceed方法，其逻辑就是调用当前方法，
所以如果在intercept中需要继续调用当前方法的话可以调用invocation的procced方法。



Mybatis拦截器常常会被用来进行分页处理。我们知道要利用JDBC对数据库进行操作就必须要有一个对应的Statement对象，
Mybatis在执行Sql语句前也会产生一个包含Sql语句的Statement对象，而且对应的Sql语句是在Statement之前产生的，
所以我们就可以在它成Statement之前对用来生成Statement的Sql语句下手。
在Mybatis中Statement语句是通过RoutingStatementHandler对象的prepare方法生成的。
所以利用拦截器实现Mybatis分页的一个思路就是拦截StatementHandler接口的prepare方法，
然后在拦截器方法中把Sql语句改成对应的分页查询Sql语句，之后再调用StatementHandler对象的prepare方法，即调用invocation.proceed()。

分页拦截：

/** 
 * 利用拦截器实现Mybatis分页的原理： 
 * 要利用JDBC对数据库进行操作就必须要有一个对应的Statement对象，Mybatis在执行Sql语句前就会产生一个包含Sql语句的Statement对象，
 * 而且对应的Sql语句是在Statement之前产生的，所以我们就可以在它生成Statement之前对用来生成Statement的Sql语句下手。
 * 在Mybatis中Statement语句是通过RoutingStatementHandler对象的prepare方法生成的。 
 * 所以利用拦截器实现Mybatis分页的一个思路就是拦截StatementHandler接口的prepare方法，
 * 然后在拦截器方法中把Sql语句改成对应的分页查询Sql语句，之后再调用StatementHandler对象的prepare方法，即调用invocation.proceed()。 
 * 对于分页而言，在拦截器里面我们还需要做的一个操作就是统计满足当前条件的记录一共有多少，这是通过获取到了原始的Sql语句后，
 * 把它改为对应的统计语句再利用Mybatis封装好的参数和设 
 * 置参数的功能把Sql语句中的参数进行替换，之后再执行查询记录数的Sql语句进行总记录数的统计。 
 */  
@Intercepts( {  
       @Signature(method = "prepare", type = StatementHandler.class, args = {Connection.class}) 
})  
public class PageInterceptor implements Interceptor {  
   
    private String databaseType;//数据库类型，不同的数据库有不同的分页方法  
     
    /** 
     * 拦截后要执行的方法 
     */  
    public Object intercept(Invocation invocation) throws Throwable {  
       //对于StatementHandler其实只有两个实现类，一个是RoutingStatementHandler，另一个是抽象类BaseStatementHandler，  
       //BaseStatementHandler有三个子类，分别是SimpleStatementHandler，PreparedStatementHandler和CallableStatementHandler，  
       //SimpleStatementHandler是用于处理Statement的，PreparedStatementHandler是处理PreparedStatement的，而CallableStatementHandler是  
       //处理CallableStatement的。Mybatis在进行Sql语句处理的时候都是建立的RoutingStatementHandler，而在RoutingStatementHandler里面拥有一个  
       //StatementHandler类型的delegate属性，RoutingStatementHandler会依据Statement的不同建立对应的BaseStatementHandler，即SimpleStatementHandler、  
       //PreparedStatementHandler或CallableStatementHandler，在RoutingStatementHandler里面所有StatementHandler接口方法的实现都是调用的delegate对应的方法。  
       //我们在PageInterceptor类上已经用@Signature标记了该Interceptor只拦截StatementHandler接口的prepare方法，又因为Mybatis只有在建立RoutingStatementHandler的时候  
       //是通过Interceptor的plugin方法进行包裹的，所以我们这里拦截到的目标对象肯定是RoutingStatementHandler对象。  
       RoutingStatementHandler handler = (RoutingStatementHandler) invocation.getTarget();  
       //通过反射获取到当前RoutingStatementHandler对象的delegate属性  
       StatementHandler delegate = (StatementHandler)ReflectUtil.getFieldValue(handler, "delegate");  
       //获取到当前StatementHandler的 boundSql，这里不管是调用handler.getBoundSql()还是直接调用delegate.getBoundSql()结果是一样的，因为之前已经说过了  
       //RoutingStatementHandler实现的所有StatementHandler接口方法里面都是调用的delegate对应的方法。  
       BoundSql boundSql = delegate.getBoundSql();  
       //拿到当前绑定Sql的参数对象，就是我们在调用对应的Mapper映射语句时所传入的参数对象  
       Object obj = boundSql.getParameterObject();  
       //这里我们简单的通过传入的是Page对象就认定它是需要进行分页操作的。  
       if (obj instanceof Page<?>) {  
           Page<?> page = (Page<?>) obj;  
           //通过反射获取delegate父类BaseStatementHandler的mappedStatement属性  
           MappedStatement mappedStatement = (MappedStatement)ReflectUtil.getFieldValue(delegate, "mappedStatement");  
           //拦截到的prepare方法参数是一个Connection对象  
           Connection connection = (Connection)invocation.getArgs()[0];  
           //获取当前要执行的Sql语句，也就是我们直接在Mapper映射语句中写的Sql语句  
           String sql = boundSql.getSql();  
           //给当前的page参数对象设置总记录数  
           this.setTotalRecord(page,  
                  mappedStatement, connection);  
           //获取分页Sql语句  
           String pageSql = this.getPageSql(page, sql);  
           //利用反射设置当前BoundSql对应的sql属性为我们建立好的分页Sql语句  
           ReflectUtil.setFieldValue(boundSql, "sql", pageSql);  
       }  
       return invocation.proceed();  
    }  
   
   
    /** 
     * 拦截器对应的封装原始对象的方法 
     */  
    public Object plugin(Object target) {  
       return Plugin.wrap(target, this);  
    }  
   
    /** 
     * 设置注册拦截器时设定的属性 
     */  
    public void setProperties(Properties properties) {  
       this.databaseType = properties.getProperty("databaseType");  
    }  
     
    /** 
     * 根据page对象获取对应的分页查询Sql语句，这里只做了两种数据库类型，Mysql和Oracle 
     * 其它的数据库都 没有进行分页 
     * 
     * @param page 分页对象 
     * @param sql 原sql语句 
     * @return 
     */  
    private String getPageSql(Page<?> page, String sql) {  
       StringBuffer sqlBuffer = new StringBuffer(sql);  
       if ("mysql".equalsIgnoreCase(databaseType)) {  
           return getMysqlPageSql(page, sqlBuffer);  
       } else if ("oracle".equalsIgnoreCase(databaseType)) {  
           return getOraclePageSql(page, sqlBuffer);  
       }  
       return sqlBuffer.toString();  
    }  
     
    /** 
     * 获取Mysql数据库的分页查询语句 
     * @param page 分页对象 
     * @param sqlBuffer 包含原sql语句的StringBuffer对象 
     * @return Mysql数据库分页语句 
     */  
    private String getMysqlPageSql(Page<?> page, StringBuffer sqlBuffer) {  
       //计算第一条记录的位置，Mysql中记录的位置是从0开始的。  
       int offset = (page.getPageNo() - 1) * page.getPageSize();  
       sqlBuffer.append(" limit ").append(offset).append(",").append(page.getPageSize());  
       return sqlBuffer.toString();  
    }  
     
    /** 
     * 获取Oracle数据库的分页查询语句 
     * @param page 分页对象 
     * @param sqlBuffer 包含原sql语句的StringBuffer对象 
     * @return Oracle数据库的分页查询语句 
     */  
    private String getOraclePageSql(Page<?> page, StringBuffer sqlBuffer) {  
       //计算第一条记录的位置，Oracle分页是通过rownum进行的，而rownum是从1开始的  
       int offset = (page.getPageNo() - 1) * page.getPageSize() + 1;  
       sqlBuffer.insert(0, "select u.*, rownum r from (").append(") u where rownum < ").append(offset + page.getPageSize());  
       sqlBuffer.insert(0, "select * from (").append(") where r >= ").append(offset);  
       //上面的Sql语句拼接之后大概是这个样子：  
       //select * from (select u.*, rownum r from (select * from t_user) u where rownum < 31) where r >= 16  
       return sqlBuffer.toString();  
    }  
     
    /** 
     * 给当前的参数对象page设置总记录数 
     * 
     * @param page Mapper映射语句对应的参数对象 
     * @param mappedStatement Mapper映射语句 
     * @param connection 当前的数据库连接 
     */  
    private void setTotalRecord(Page<?> page,  
           MappedStatement mappedStatement, Connection connection) {  
       //获取对应的BoundSql，这个BoundSql其实跟我们利用StatementHandler获取到的BoundSql是同一个对象。  
       //delegate里面的boundSql也是通过mappedStatement.getBoundSql(paramObj)方法获取到的。  
       BoundSql boundSql = mappedStatement.getBoundSql(page);  
       //获取到我们自己写在Mapper映射语句中对应的Sql语句  
       String sql = boundSql.getSql();  
       //通过查询Sql语句获取到对应的计算总记录数的sql语句  
       String countSql = this.getCountSql(sql);  
       //通过BoundSql获取对应的参数映射  
       List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();  
       //利用Configuration、查询记录数的Sql语句countSql、参数映射关系parameterMappings和参数对象page建立查询记录数对应的BoundSql对象。  
       BoundSql countBoundSql = new BoundSql(mappedStatement.getConfiguration(), countSql, parameterMappings, page);  
       //通过mappedStatement、参数对象page和BoundSql对象countBoundSql建立一个用于设定参数的ParameterHandler对象  
       ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, page, countBoundSql);  
       //通过connection建立一个countSql对应的PreparedStatement对象。  
       PreparedStatement pstmt = null;  
       ResultSet rs = null;  
       try {  
           pstmt = connection.prepareStatement(countSql);  
           //通过parameterHandler给PreparedStatement对象设置参数  
           parameterHandler.setParameters(pstmt);  
           //之后就是执行获取总记录数的Sql语句和获取结果了。  
           rs = pstmt.executeQuery();  
           if (rs.next()) {  
              int totalRecord = rs.getInt(1);  
              //给当前的参数page对象设置总记录数  
              page.setTotalRecord(totalRecord);  
           }  
       } catch (SQLException e) {  
           e.printStackTrace();  
       } finally {  
           try {  
              if (rs != null)  
                  rs.close();  
               if (pstmt != null)  
                  pstmt.close();  
           } catch (SQLException e) {  
              e.printStackTrace();  
           }  
       }  
    }  
     
    /** 
     * 根据原Sql语句获取对应的查询总记录数的Sql语句 
     * @param sql 
     * @return 
     */  
    private String getCountSql(String sql) {  
         
       return "select count(1) from (" + sql + ")";  
    }  
     
    /** 
     * 利用反射进行操作的一个工具类 
     * 
     */  
    private static class ReflectUtil {  
       /** 
        * 利用反射获取指定对象的指定属性 
        * @param obj 目标对象 
        * @param fieldName 目标属性 
        * @return 目标属性的值 
        */  
       public static Object getFieldValue(Object obj, String fieldName) {  
           Object result = null;  
           Field field = ReflectUtil.getField(obj, fieldName);  
           if (field != null) {  
              field.setAccessible(true);  
              try {  
                  result = field.get(obj);  
              } catch (IllegalArgumentException e) {  
                  // TODO Auto-generated catch block  
                  e.printStackTrace();  
              } catch (IllegalAccessException e) {  
                  // TODO Auto-generated catch block  
                  e.printStackTrace();  
              }  
           }  
           return result;  
       }  
        
       /** 
        * 利用反射获取指定对象里面的指定属性 
        * @param obj 目标对象 
        * @param fieldName 目标属性 
        * @return 目标字段 
        */  
       private static Field getField(Object obj, String fieldName) {  
           Field field = null;  
          for (Class<?> clazz=obj.getClass(); clazz != Object.class; clazz=clazz.getSuperclass()) {  
              try {  
                  field = clazz.getDeclaredField(fieldName);  
                  break;  
              } catch (NoSuchFieldException e) {  
                  //这里不用做处理，子类没有该字段可能对应的父类有，都没有就返回null。  
              }  
           }  
           return field;  
       }  
   
       /** 
        * 利用反射设置指定对象的指定属性为指定的值 
        * @param obj 目标对象 
        * @param fieldName 目标属性 
         * @param fieldValue 目标值 
        */  
       public static void setFieldValue(Object obj, String fieldName,  
              String fieldValue) {  
           Field field = ReflectUtil.getField(obj, fieldName);  
           if (field != null) {  
              try {  
                  field.setAccessible(true);  
                  field.set(obj, fieldValue);  
              } catch (IllegalArgumentException e) {  
                  // TODO Auto-generated catch block  
                  e.printStackTrace();  
              } catch (IllegalAccessException e) {  
                  // TODO Auto-generated catch block  
                  e.printStackTrace();  
              }  
           }  
        }  
    }  
   
}  

    public Map<String, Object> getParams() {  
       return params;  
    }  
     
    public void setParams(Map<String, Object> params) {  
       this.params = params;  
    }  
   
    @Override  
    public String toString() {  
       StringBuilder builder = new StringBuilder();  
       builder.append("Page [pageNo=").append(pageNo).append(", pageSize=")  
              .append(pageSize).append(", results=").append(results).append(  
                     ", totalPage=").append(totalPage).append(  
                     ", totalRecord=").append(totalRecord).append("]");  
       return builder.toString();  
    }  
   
}  
